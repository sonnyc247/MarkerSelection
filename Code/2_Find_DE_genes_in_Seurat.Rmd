---
title: "2: Finding markers with Seurat"
author: "Sonny"
output: html_document
---

This notebook/script places after "1_Loading_and_selecting_data.Rmd". We are now finding cell subclass markers (differentially expressed genes) with Seurat and the AIBS data (accessed on Aug 4, 2020). As implied, we assume that Seurat (V3+) is installed.

First, we convert the raw count data into a Seurat object

```{r, data load and prep in Seurat}

library(Seurat) #load the needed library

#check that the inputs are formatted correctly
t(new_count_matrix[1:5,1:10]) #count matrix will need to be transposed for Seurat
new_metadata_filtered[1:10,1:5] #this is formated correctly (in terms of rows and columns) but will set rownames just in case
row.names(new_metadata_filtered) <- new_metadata_filtered$sample_name #setting row names to sample names
new_metadata_filtered[1:10,1:5] #checking the metadata df again

new_Seu_AIBS_obj <- CreateSeuratObject(counts = t(new_count_matrix), meta.data = new_metadata_filtered) #this creates the Seurat object from our data

```

For those who are new to Seurat, we can do the following to check that we have created the Seurat object correctly.

```{r, checking Seurat object}
### comfirming count matrix
test <- as.data.frame(new_Seu_AIBS_obj@assays$RNA@counts) #extracting count matrix from Seurat object

#the follow need to be done to change the format of "test", not any data within it; this will allow us to use "identical" to compare "test" and the original count data in new_count_matrix
test <- t(test) #transpose
test <- as.data.frame(test) #change to df
temp_rownames <- row.names(test) #save rownames
test <- lapply(test, as.integer) #change all columns to integer
test <- as.data.frame(test) #change back to df
row.names(test) <- temp_rownames #reassign rownames

identical(test, new_count_matrix) #indentical check; will be TRUE

remove(temp_rownames) #remove temporary object

### confirming metadata
test <- as.data.frame(new_Seu_AIBS_obj@meta.data) #extracting metadata from Seurat object
test <- test[,4:ncol(test)] #removing extra columns made by Seurat
identical(test, new_metadata_filtered) #identical test, should be TRUE

remove(test) #remove temporary test object

```

We next normalize our data.

```{r, normalize data}

new_Seu_AIBS_obj <- NormalizeData(new_Seu_AIBS_obj, normalization.method = "LogNormalize", scale.factor = 1000000)

new_Seu_AIBS_obj[["RNA"]]@data[1:10,1:10] #preview/see our normalized data

```

For our purposes, we may next want to further remove some groups, such as neurons from the CgG or MTG for two separate analyses.

```{r, subset data}

Idents(new_Seu_AIBS_obj) <- "NeuN_Region" #we identify samples by "NeuN_Region", which we made befire in 1_Loading_and_selecting_data.Rmd to make it easy for us to remove neurons from MTG/CgG later

new_Seu_AIBS_obj_for_test <- subset(new_Seu_AIBS_obj, idents = "MTG_Neuronal", invert = TRUE) #remove "MTG_Neuronal" cells

table(new_Seu_AIBS_obj_for_test$subclass_label) #check what subclasses we have

Idents(new_Seu_AIBS_obj_for_test) <- "subclass_label" #assign "subclass_label" as the key grouping variable now
new_Seu_AIBS_obj_for_test <- subset(new_Seu_AIBS_obj_for_test, idents = "L4 IT", invert = TRUE) #remove "L4 IT" cell since there is an N of 1

```

We are almost ready to find cell markers. If we had a small dataset, or cared only for some specific comparisons, or for any other reason want to go directly into finding markers with default settings from Seurat, we can use the following example code.

```{r, simple/direct marker/DE gene selection}

Idents(new_Seu_AIBS_obj_for_test) <- "subclass_label" #apply/assign/confirm our identity labels of interest to cells, if not already done so

# do all comparisons, using defaults (Wilcoxon rank-sum test)
new_AIBS_markers <- FindAllMarkers(object = new_Seu_AIBS_obj) # if computational resources/time is not an issue, we can run this using all default settings; this is not run for the generation of this notbook

# if you want to find markers for each group separately, you can use the example code below:
new_AIBS_SST_markers <- FindMarkers(new_Seu_AIBS_obj, ident.1 = "SST") #this is not run for the generation of this notbook


```

For our purposes/example, to find markers (for cell subclass/specified grouping variable), we calculate markers by using the FindAllMarkers function. There are many arguments/thresholds we can use in this case, and to determine the best thresholds to use, we may want to check on the characteristic metrics (such what percentage of a group of cells express a gene) of key, cluster-defining/namesake markers. For our (demonstration) purposes, our key markers are LAMP5, VIP, SST, PVALB, and PAX6.

```{r, screen data for threshold}

Idents(new_Seu_AIBS_obj_for_test) <- "subclass_label" #apply/assign/confirm our identity labels of interest to cells, if not already done so

# for us, we want to use MAST for single-cell datasets (this is not strictly necessary for the screening step, but will be what we ultimately use to find markers)

BiocManager::install("MAST") #if/as needed
library("MAST")

new_AIBS_markers_screen_CgG <- FindAllMarkers(new_Seu_AIBS_obj_for_test, slot = "data", logfc.threshold = .1, min.pct = .1, only.pos = TRUE, return.thresh = .05, test.use = "MAST") # we use this as a dummy run; we don't care about these results per se, but rather the fold-changes and detected percentages of key markers in their cannonical groups (e.g: SST in SST cluster) 

new_AIBS_markers_screen_CgG[new_AIBS_markers_screen_CgG$cluster == new_AIBS_markers_screen_CgG$gene,] #see namesake gene's fc and pct

write.csv(new_AIBS_markers_screen_CgG, "/external/rprshnas01/kcni/ychen/git/MarkerSelection/Data/Outputs/new_screen_CgG_results.csv") #save screen results

```

We can see from the screen that the pct.1 minumum is 0.361 and the avg_logFC minimum is 1.09. In theory, we can use these as threshold values of pct and log fold-change in FindAllMarkers. However, the low difference in PAX6 is notable. We can look into this by looking at average gene expression of PAX6 amongst our groups.

```{r, see average expression values of PAX6 amongst cell groups}

new_CgG_averages <- AverageExpression(new_Seu_AIBS_obj_for_test) #getting averages
new_CgG_averages <- new_CgG_averages$RNA #converting format
new_CgG_averages["PAX6",] #see PAX6 averages
new_CgG_averages["PAX6",c("PAX6", "Astrocyte")] #focus on PAX6 and Astrocyte

```

Thus, we can see that high expression of PAX6 in Astrocytes may be contributing to the low fold-change when comparing PAX6 and other cell groups. For our purposes, we will use 0.35 for the pct threshold and a log fold-change cut-off of 2.5 based on prior experience and for consistency with prior analyses (see Run_V1). These thresholds will also still alow us to include the namesake markers (with the obvious exception of PAX6). We will now find our markers using these thresholds. We like using both the MAST test and the roc test for useful metrics.

```{r, find markers for CgG}

Idents(new_Seu_AIBS_obj_for_test) <- "subclass_label" #apply/assign/confirm our identity labels of interest to cells, if not already done so
library("MAST") #check that mast is loaded

new_AIBS_markers_mast_CgG <- FindAllMarkers(new_Seu_AIBS_obj_for_test, slot = "data", logfc.threshold = 2.5, min.pct = .35, only.pos = TRUE, return.thresh = .05, test.use = "MAST") #find markers

new_AIBS_markers_roc_CgG <- FindAllMarkers(new_Seu_AIBS_obj_for_test, slot = "data", logfc.threshold = 2.5, min.pct = .35, only.pos = TRUE, return.thresh = .05, test.use = "roc") #find markers using roc

head(new_AIBS_markers_mast_CgG) #preview our results

```

The results (when using FindAllMarkers) are in one dataframe in a "gathered" format (a column for your queried cell group) with all marker genes. The default results also have adjusted p values ranging from 1 to 0 (or near to it). We now check for duplicated genes, which may mean that they are markers of multiple cell groups. For our purposes, we want unique/specific cell markers, so we remove all instances of duplicates.

```{r, remove duplicate/non-specific markers}

### for mast
length(unique(new_AIBS_markers_mast_CgG$gene)) #check for unique marker genes
dup_list <- unique(new_AIBS_markers_mast_CgG[duplicated(new_AIBS_markers_mast_CgG$gene),"gene"]) #list of duplicated genes
new_AIBS_markers_mast_CgG <- new_AIBS_markers_mast_CgG[!(new_AIBS_markers_mast_CgG$gene %in% dup_list),] #remove duplicated marker genes

### for roc
length(unique(new_AIBS_markers_roc_CgG$gene)) #check for unique marker genes
dup_list <- unique(new_AIBS_markers_roc_CgG[duplicated(new_AIBS_markers_roc_CgG$gene),"gene"]) #list of duplicated genes
new_AIBS_markers_roc_CgG <- new_AIBS_markers_roc_CgG[!(new_AIBS_markers_roc_CgG$gene %in% dup_list),] #remove duplicated marker genes

length(intersect(new_AIBS_markers_mast_CgG$gene, new_AIBS_markers_roc_CgG$gene)) #see intersect of marker genes
table(new_AIBS_markers_roc_CgG$cluster) #see breakdown of markers by group

```

Finally, we combine/merge the two, to one set of results, and add entrez/ensembl IDs (or other metadata, as desired).

```{r, finalize result df and save output}

Result_df <- merge(new_AIBS_markers_roc_CgG[,c(7,6,4,5,2,1,3)], new_AIBS_markers_mast_CgG[,c(1,5,7)], by = "gene", all.x = TRUE, all.y = TRUE) #combine the marker df; may want to double check the indices/order

### to add entrez and ensembl IDs to the output/result df

# our mgi-to-entrez ID conversion comes from a file from AIBS http://celltypes.brain-map.org/api/v2/well_known_file_download/694416044
human_MTG_2018_06_14_genes_rows <- read_csv("~/git/MarkerSelection/Data/Inputs/human_MTG_2018-06-14_genes-rows.csv") #loading the conversion data for entrez IDs from AIBS

library('biomaRt') #load biomart for getting ensembl ID
ensembl <- useMart("ensembl", dataset="hsapiens_gene_ensembl") #load human gene dataset
test <- listAttributes(ensembl) #see fields of data we can pull
Gene_anno <- getBM(c("entrezgene_id", "ensembl_gene_id"), mart=ensembl) # getting ensembl gene IDs, will convert from entrez IDs
remove(ensembl) #remove no-longer needed object
Gene_anno <- aggregate(ensembl_gene_id ~ entrezgene_id, Gene_anno, FUN = toString) #aggregate cases of multiple ensembl ID per entrez ID
Gene_anno <- merge(human_MTG_2018_06_14_genes_rows, Gene_anno, by.x = "entrez_id", by.y = "entrezgene_id", all.x = TRUE) #merge for final gene ID conversion df, using the AIBS df as the master

Result_df <- merge(Gene_anno[,c("gene", "entrez_id", "ensembl_gene_id")], Result_df, by = "gene", all.y = TRUE) #add entrez and ensembl ids, keeping all results, even if they don't have a corresponding entry from Gene-Anno
colnames(Result_df)[c(3,4,7:11)] <- c("ensembl_id", "subclass", "avg_logFC", "roc_myAUC", "roc_power", "MAST_p_val","MAST_p_val_adj") #rename some columns for clarity

new_CgG_results <- Result_df #store the results in R

write.csv(new_CgG_results, "/external/rprshnas01/kcni/ychen/git/MarkerSelection/Data/Outputs/new_CgG_results.csv") #save/export results

```

For our purposes, we also want to find markers using MTG Neurons.

```{r, find markers for MTG}
### filter data
Idents(new_Seu_AIBS_obj) <- "NeuN_Region" #we identify samples by "NeuN_Region", which we made befire in 1_Loading_and_selecting_data.Rmd to make it easy for us to remove neurons from MTG/CgG later

new_Seu_AIBS_obj_for_test <- subset(new_Seu_AIBS_obj, idents = "CgG_Neuronal", invert = TRUE) #remove "CgG_Neuronal" cells

table(new_Seu_AIBS_obj_for_test$subclass_label) #double check what subclasses we have

Idents(new_Seu_AIBS_obj_for_test) <- "subclass_label" #assign "subclass_label" as the key grouping variable now

### screen data

library("MAST") #as needed

new_AIBS_markers_screen_MTG <- FindAllMarkers(new_Seu_AIBS_obj_for_test, slot = "data", logfc.threshold = .2, min.pct = .2, only.pos = TRUE, return.thresh = .05, test.use = "MAST") # we use this as a dummy run; we don't care about these results per se, but rather the fold-changes and detected percentages of key markers in their cannonical groups (e.g: SST in SST cluster); we made the thresholds slightly more stringent here than for CgG, to speed up the analysis

new_AIBS_markers_screen_MTG[new_AIBS_markers_screen_MTG$cluster == new_AIBS_markers_screen_MTG$gene,] #see namesake gene's fc and pct

write.csv(new_AIBS_markers_screen_MTG, "/external/rprshnas01/kcni/ychen/git/MarkerSelection/Data/Outputs/new_screen_MTG_results.csv") #save screen results

### find markers

new_AIBS_markers_mast_MTG <- FindAllMarkers(new_Seu_AIBS_obj_for_test, slot = "data", logfc.threshold = 2.5, min.pct = .35, only.pos = TRUE, return.thresh = .05, test.use = "MAST") #find markers

new_AIBS_markers_roc_MTG <- FindAllMarkers(new_Seu_AIBS_obj_for_test, slot = "data", logfc.threshold = 2.5, min.pct = .35, only.pos = TRUE, return.thresh = .05, test.use = "roc") #find markers using roc

### remove duplicates

dup_list <- unique(new_AIBS_markers_mast_MTG[duplicated(new_AIBS_markers_mast_MTG$gene),"gene"]) #list of duplicated genes
new_AIBS_markers_mast_MTG <- new_AIBS_markers_mast_MTG[!(new_AIBS_markers_mast_MTG$gene %in% dup_list),] #remove duplicated marker genes

dup_list <- unique(new_AIBS_markers_roc_MTG[duplicated(new_AIBS_markers_roc_MTG$gene),"gene"]) #list of duplicated genes
new_AIBS_markers_roc_MTG <- new_AIBS_markers_roc_MTG[!(new_AIBS_markers_roc_MTG$gene %in% dup_list),] #remove duplicated marker genes

remove(dup_list) #clean temporary object

### finalize df

length(intersect(new_AIBS_markers_mast_MTG$gene, new_AIBS_markers_roc_MTG$gene)) #see intersect of marker genes
Result_df <- merge(new_AIBS_markers_roc_MTG[,c(7,6,4,5,2,1,3)], new_AIBS_markers_mast_MTG[,c(1,5,7,6,3,4,2)], by = "gene", all.x = TRUE, all.y = TRUE) #combine the marker df; may want to double check the indices/order
unique_genes <- setdiff(new_AIBS_markers_mast_MTG$gene, new_AIBS_markers_roc_MTG$gene) #genes unique to mast_MTG
Result_df[Result_df$gene %in% unique_genes, 2:5] <- Result_df[Result_df$gene %in% unique_genes, 10:13] #fill in metrics unique to mast_MTG
Result_df <- Result_df[,1:9] #remove redundant columns

Result_df <- merge(Gene_anno[,c("gene", "entrez_id", "ensembl_gene_id")], Result_df, by = "gene", all.y = TRUE) #add entrez and ensembl ids, keeping all results, even if they don't have a corresponding entry from Gene-Anno
colnames(Result_df)[c(3:11)] <- c("ensembl_id", "subclass", "pct.1", "pct.2", "avg_logFC", "roc_myAUC", "roc_power", "MAST_p_val","MAST_p_val_adj") #rename some columns for clarity

new_MTG_results <- Result_df #store the results in R
write.csv(new_MTG_results, "/external/rprshnas01/kcni/ychen/git/MarkerSelection/Data/Outputs/new_MTG_results.csv") #save/export results

```

As an aside/extra, we can also try finding markers by systematically doing pairwise comparisons between a key group and all other groups. We do this for SST cells in the example below.

```{r, pairwise}

paircomp_groups <- unique(Idents(new_Seu_AIBS_obj_for_test)) #get list of all groups
query_group <- "SST" #set group of interest
paircomp_groups = paircomp_groups[!paircomp_groups %in% query_group] #remove group of interest from list of cell groups (e.g: no need to compare SST to SST)

new_AIBS_markers_pair_mast_MTG_SST <- data.frame(p_val=double(),
                 avg_logFC=double(),
                 pct.1=double(),
                 pct.2=double(),
                 p_val_adj=double(),
                 group_2=character(),
                 stringsAsFactors=FALSE) #initialize blank result df

for (cluster_name in paircomp_groups) { #for every non-key (non-SST in this case) group,

  temp_df <- FindMarkers(object = new_Seu_AIBS_obj_for_test, ident.1 = query_group, ident.2 = cluster_name, logfc.threshold = 2.5, min.pct = .35, only.pos = TRUE, test.use = "MAST") #get results for pairwise comparison between group of interest and current group in loop
  temp_df$group_2 <- cluster_name #add new column indicating the comparator/group 2
  new_AIBS_markers_pair_mast_MTG_SST <- rbind(new_AIBS_markers_pair_mast_MTG_SST, temp_df) #add results to overall result df

}
 
```

This is the end of this notebook for now. We can now take this list of markers and evaluate them or use them for other analyses.
